# 缓存
数据一般放在数据库里，数据库里的数据都落地到磁盘上。因此用户请求都访问数据库的话，请求数量上来了，数据库会扛不住压力，因为磁盘 I/O 本身就相当的慢

而 Redis 作为内存数据库充当一层缓冲。在服务刚启起来时，可以先把数据库里的数据加载到 Redis，后续的请求都走 Redis，因为 Redis 本来就是内存数据库，速度会快上许多，也减少了数据库压力

<h3>缓存雪崩 </h3>
从数据库里读取数据到 Redis 时，一般会设置一个过期时间，时间过了之后就更新数据。倘若大量数据在同一时间过期或者 Redis 宕机，那么缓冲就失效了，所有的
请求就打到了数据库上，最后导致数据库崩溃。

下面分情况介绍解决办法  
**大量数据同时过期**
- 均匀设置过期时间，给过期时间加上一个随机数
- 互斥锁，当发现 Redis 里面数据失效时，加锁，让一个请求到达数据库，加载数据到 Redis，然后解锁。剩下的请求仍然能走 Redis
要注意可能拿到锁的请求因为一些原因一直阻塞而不释放锁，可以加上一个释放锁的最长时间
- 双 Key 缓存，对缓存数据使用两个 Key，一个主 Key，设置过期时间，一个副 key，不设置过期时间，当访问不到主 Key 时，就去访问副 Key，同时更新缓存，更新主 Key 和 副 Key
- 后台更新缓存，不让业务线程去更新缓存，后台定期更新 （一般配合缓存预热使用）
缓存预热就是在业务刚上线时，就提前查一次数据并加入 redis 缓存

**Redis 故障宕机**  
- 服务熔断或请求限流     
服务熔断：当 Redis 宕机后，业务线程的请求直接返回错误，从而降低对数据库的访问压力。等 Redis 恢复正常了再允许业务访问
请求限流：因为服务熔断会直接影响拒绝业务请求，为了减少对业务的影响，可以限制只将少部分请求发送到数据库，再多的请求在入口就拒绝服务。等到 Redis 恢复正常并预热后，再解除

- 构建 Redis 缓存高可用集群  
构建主从节点，主节点挂了就去访问从节点

<h3>缓存击穿</h3>
热点数据过期，同时间大量请求打到数据库，解决办法如下：
- 互斥锁
- 不给热点数据设置过期时间，由后台异步更新。在要过期的时候更新数据或延长过期时间

<h3>缓存穿透</h3>
访问的数据既不在缓存也不在数据库中，导致的情况有一下几种：
- 业务的误删除操作
- 黑客的恶意攻击

应对的方法常见的有三种：
- 非法请求的限制
- 缓存空值或者默认值
- 使用布隆过滤器快速判断数据是否存在，避免通过数据库来查询    
布隆过滤器的实现是基于位图和哈希函数实现。每次写入数据时，通过 N 个哈希函数计算出在位图上的索引值，并标记为1
，下次查询数据时，查询布隆过滤器即可，通过哈希函数定位到 N 个索引值，只要存在值为0，就说明数据不存在。但是哈希函数
会存在哈希冲突，因此布隆过滤器说明数据存在时，数据库不一定能查询到数据。