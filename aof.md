# AOF 持久化

AOF 持久化是为了弥补 RDB 持久化中数据丢失的不可控制性和在执行 RDB 时消耗的大量资源(需要把所有数据库的所有键值都拷贝到
RDB 文件)
而存在的一种持久化。AOF 非常类似于 mysql 中的 redo 日志，它们都是记录每条使得服务器状态做出改变的命令，以顺序 IO 插入到 AOF
文件中

redis 的 AOF 持久化命令默认是不开启的，修改 redis.conf 配置文件中的参数修改

```yaml
appendonly           yes
appendfilename      "appendonly.aof"
```
**AOF 文件格式**   
例如写入 set name dto,那么写入 aof 文件中的格式为:
```aof
*3  // 表示命令有 3 部分
$3  // 表示接下来有 3 字节数据
set // 对应字节大小的数据
$4
name
$3
dto
```

当输入例如上面一行命令时，会写执行写操作，然后再写入日志，这样的好处：  

- 可以保证写入文件命令的正确性，如果执行不正确，则不会写入文件
- 避免阻塞写命令

但是因为把执行命令和写入日志分为了两步操作，倘如执行完第一步断点了，则会导致数据丢失
同时，有可能会堵塞下一个写操作，因为当前命令执行完后要写入文件

Redis 写入 AOF 日志过程：
```
执行写命令操作 -> 添加到 server.aof_buf -> I/O 系统调用 write() （用户态到内核态的转变）
->写入内核冲区->写入磁盘
```
- Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；
- 然后通过 write() 系统调用，将 aof_buf 缓冲区的数据写入到 AOF 文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区 page cache，等待内核将数据写入硬盘；
- 具体内核缓冲区的数据什么时候写入到硬盘，由内核决定。

在 redis.conf 配置文件中的 appendfsync 配置项有 3 种参数来控制上面的第三步，即从 操作系统的内核写入到磁盘。
本质是控制 fsync() 的调用时机

- always 每次写操作执行完命令后就写入磁盘
- everySec 每次执行完命令后，先写入到 内核缓冲区，然后每隔一秒将缓冲区里的内容写回硬盘
- No 意味着将写回磁盘的时机交给操作系统来控制

这 3 种写回策略都无法能完美解决「主进程阻塞」和「减少数据丢失」的问题，因为两个问题是对立的，偏向于一边的话，就会要牺牲另外一边。

**AOF 重写机制**
随着写命令不断的执行，AOF 文件会越来越大，那么在重启 redis 时读取 AOF 文件耗时会越来越长
当 AOF 大到阈值时，就会对 AOF 文件进行重写。如 原来的 AOF 重复对 name 进行赋值，那么 重写
后的 AOF 文件只会保留 name 的最后值，以此来压缩 AOF 文件的大小。

重写流程是新开一个文件，在里面进行重写，完成后再覆盖源文件。为什么不直接在源文件上进行重写呢？
原因在于倘如直接重写源文件时断电了，则会对源文件造成污染。

**AOF 后台重写机制**
AOF 重写，因为 AOF 已经到达了一定的大小，然后重新写到文件再覆盖掉源文件，还是很耗时间的，为了防止阻塞主进程，则会开启一个子进程来实现重写

- 为什么不使用线程呢？  
线程会共享一块资源，在访问时要频繁的加锁，增加额外消耗

主进程通过 fork 生成了子进程，操作系统会把主进程的**页表**复制一份给子进程，这个页表记录着虚拟内存和物理内存的映射关系，并不会复制物理内存。即 子进程和父进程对应的是一块物理内存

当主进程执行写命令操作时，会触发 CPU写保护屏障，然后会把物理内存复制一份。(写时复制)

所以有两个阶段会导致主进程阻塞：
- fork 子进程时，会进行页表的复制
- 在主进程执行写命令操作时，会进行物理内存的复制 (只复制修改的物理内存数据)

在执行写命令之后，父子进程的内存数据就不一致了，Redis 要确保数据同步到 AOF 文件中。因此会设置一个 AOF 后台重写缓存

在重写 AOF 期间，执行了写命令操作，然后 将操作 写入 AOF 缓存 和 AOF 重写缓存，等到子进程完成 AOF 重写后，会把 AOF 重写缓存写入 AOF 文件并进行覆盖
